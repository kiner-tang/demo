{"version":3,"sources":["App.tsx","reportWebVitals.ts","index.tsx"],"names":["ShowType","storageKey","App","old","localStorage","getItem","JSON","parse","e","initStore","useState","inputValue","list","showType","all","state","setState","tabList","label","value","active","done","renderList","filter","todoItem","isDone","updateState","partialState","oldState","add","content","trim","length","push","id","Math","random","Date","now","saveStore","alert","setItem","stringify","className","type","placeholder","onChange","target","onKeyDown","key","toLowerCase","onClick","map","tab","index","itemIdx","findIndex","item","splice","stopPropagation","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.2c55a234.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport \"./App.css\";\n\n// [Typescript] 对于一些有限的数据集合，可以使用枚举类型进行描述\n// 显示类型，包括显示所有事项、显示未完成事项、显示已完成事项\nexport enum ShowType {\n  all,\n  active,\n  done,\n}\n// [Typescript] 对于一些对象，我们可以使用`interface`将其结构和字段的数据类型描述出来，\n// 编辑器将根据这个结构和数据类型进行类型校验和提示\n// 每一事项的结构，包括事项的id,事项的内容content,该事项是否已完成isDone\nexport interface TodoListItem {\n  id: string;\n  content: string;\n  isDone: boolean;\n}\n// 切换显示方式的tab的结构，包括显示的文字label,以及对应的值是ShowType类型的枚举值\nexport interface TabItem {\n  label: string;\n  value: ShowType;\n}\n\n// [Typescript&React] 在React中，通过对状态的修改打到更新界面的目的，类似于Vue中的data\n// 此处定义了App的状态对象结构\n// inputValue 用户输入的文本框的值\n// list       所有事项列表，是由`TodoListItem`组成的数组\n// showType   当前要显示什么类型的事项\nexport interface AppState {\n  inputValue: string,\n  list: TodoListItem[];\n  showType: ShowType;\n}\n// 工具方法，用于创建全局唯一的id\nfunction createUUID(): string {\n  return `${Math.random() * 9999999999999}_${Date.now()}`\n}\n\n// [Typescript] 用于创建一个新的事项，传入事项的内容content,字符串类型,返回一个事项，其结构为`TodoListItem`\nfunction createTodoItem(content: string): TodoListItem {\n  return {\n    id: createUUID(),\n    content,\n    isDone: false\n  }\n}\nconst storageKey = \"kiner-todo-list\";\n\n// 为简化逻辑，我们在这里不使用接口和React全家桶中的Store解决方案，仅仅将我们的数据存储到本地存储即可\n// 需要时直接从本地存储获取回来\nfunction initStore(): TodoListItem[] {\n  let old: any = localStorage.getItem(storageKey);\n  if (old) {\n    try {\n      old = JSON.parse(old);\n    } catch (e) {\n      old = [];\n    }\n  } else {\n    old = [];\n  }\n  return old;\n}\n\n// [React] 在React中有两种创建组件的方式，一种是通过Class方式构建，另一种是通过函数方式实现，\n// [React] 他们简单介绍和各自的优缺点以及使用场景，详见：http://www.ruanyifeng.com/blog/2019/09/react-hooks.html\n// 此处为了演示以及功能相对简单，因此采用的是函数式组件\nfunction App() {\n  // 将之前的待办事项获取回来，作为初始化状态的值进行输入\n  let old = initStore();\n\n  // [React&Typescript] 在函数式组件中，如果想要使用状态，需要使用React Hooks中的`useState`hooks\n  // [React&Typescript] userState<AppState>是`Typescript`的类型约束方式，意思是我创建的state，他的结构是`AppState` \n  // [React] useState会返回一个数组，数组第一个元素就是我们的状态，第二个元素是用来改变这个状态的方法\n  const [state, setState] = useState<AppState>({\n    inputValue: \"\",\n    list: old,\n    showType: ShowType.all,\n  });\n\n  // 定义我们几个Tab的结构\n  const tabList: TabItem[] = [\n    {\n      label: \"所有事项\",\n      value: ShowType.all,\n    },\n    {\n      label: \"未完事项\",\n      value: ShowType.active,\n    },\n    {\n      label: \"已完事项\",\n      value: ShowType.done,\n    },\n  ];\n\n  // 将状态中的list,即事项列表取出来，我们需要对他进行一定的加工之后再渲染到页面上，这个操作类似于`Vue`中的`Computed`,也就是计算属性\n  const list = state.list;\n  // 对原始数据列表根据当前显示类型进行过滤\n  // 1. 如果当前显示类型为:ShowType.all,即显示所有事项，则直接返回所有事项即可\n  // 2. 如果当前显示类型为:ShowType.active,即只显示代办事项，则需要把事项列表中的已完成事项过滤掉，只返回代办事项\n  // 3. 如果当前显示类型为:ShowType.done,即只显示已完成事项，则需要把事项列表中的代办事项过滤掉，只返回已完成事项\n  const renderList = list.filter((todoItem: TodoListItem) => {\n    return state.showType === ShowType.all ||\n      (state.showType === ShowType.active && !todoItem.isDone) ||\n      (state.showType === ShowType.done && todoItem.isDone)\n  });\n\n  // 由于我们的状态使用的是一个对象，为了方便更新状态中的某一个属性的值，如只更新`showType`的值，我们封装一个工具方法，\n  // 使我们只需要传入一个新的对象，这个方法会自动帮我们将新旧状态合并并更新\n  const updateState = (partialState: any) =>\n    setState(oldState => ({\n      ...oldState,\n      ...partialState\n    }));\n\n  // 用于添加代办事项\n  function add(): void {\n    if (!state.inputValue.trim().length) {\n      alert('请输入代办事项的内容');\n      return;\n    }\n    // 将用户输入的事项内容使用`createTodoItem`方法创建一个代办事项并塞到事项列表中\n    list.push(createTodoItem(state.inputValue));\n    // [React] 不同于`Vue`的数据响应式，在React中，如果数据改变了，想要重新渲染页面，需要调用`setState`方法进行更新，\n    // [React] 我们上面封装了一个便捷操作方法`updateState`便是为了这个目的\n    // 将新的列表传入，并将文本框中的文字情况\n    updateState({\n      list,\n      inputValue: \"\"\n    });\n    // 由于没有请求接口，我们使用此方法将我们的数据保存到localStorage中进行数据持久化\n    saveStore();\n  }\n\n  // 将我们的事项列表保存在localStorage中，这样刷新页面就不会导致之前添加的代办事项丢失\n  function saveStore() {\n    localStorage.setItem(storageKey, JSON.stringify(list));\n  }\n\n\n  return (\n    <div className=\"App\">\n      <div className=\"input-box\">\n        <input\n          type=\"text\"\n          placeholder=\"请输入待办事项\"\n          // 将状态中的inputValue绑定到value中，一旦我们的inputValue发生变化重新渲染时，\n          // 我们的文本框里面的内容也会相应变化\n          value={state.inputValue}\n          // 当用户输入时，我们需要实时更新inputValue\n          // 这一步与上面绑定value一起，在Vue中一般是使用v-model进行双向绑定的\n          onChange={e => updateState({ inputValue: e.target.value })}\n          // 当用户在文本框中输入回车时，我们就执行增加代办事项方法进行添加待办事项\n          onKeyDown={(e) => {\n            if (e.key.toLowerCase() === \"enter\") {\n              add();\n            }\n          }}\n        />\n        {/* 点击按钮时也同样执行添加代办事项的方法 */}\n        <button className=\"add-btn\" onClick={() => {\n          add();\n        }}>添加代办事项</button>\n      </div>\n      <div className=\"todo-list-penel\">\n        {/* 用于切换显示类型的tab栏 */}\n        <div className=\"tab-box\">\n          {/* [React] 在React中，如果需要循环遍历一个数组，一般采用数组的map方法，返回一个ReactNode，也就是jsx表达式 */}\n          {tabList.map((tab: TabItem) => (\n            <div\n              // [react] 注意，再循环列表是，需要给循环生成的最外层元素加上唯一的key，以防止渲染异常和提高渲染性能\n              key={tab.label}\n              // 根据当前显示类型的不同让指定的tab处于激活状态\n              className={`tab${state.showType === tab.value ? \" active\" : \"\"}`}\n              onClick={() => {\n                updateState({\n                  showType: tab.value\n                })\n              }}\n            >\n              {tab.label}\n            </div>\n          ))}\n        </div>\n        <div className=\"list-box\">\n          {\n            renderList.map((todoItem: TodoListItem, index: number) => <div\n              className={`todo-item${todoItem.isDone ? ' done' : ''}`}\n              key={`${todoItem.id}`}\n              onClick={() => {\n                // 我们要将一个已完成事项改为未完成，或将一个未完成事项改为已完成，首先，先拿到这个事项在整个列表中索引\n                const itemIdx = list.findIndex(item => item.id === todoItem.id);\n                // 改变当前事项的完成状态\n                todoItem.isDone = !todoItem.isDone;\n                // 对事项列表进行原地修改\n                list.splice(itemIdx, 1, todoItem);\n                // 更新列表触发重新渲染\n                updateState({\n                  list\n                });\n                // 数据持久化\n                saveStore();\n              }}\n            >\n              <span className=\"checkbox\"></span>\n              <span className=\"idx\">{index + 1}</span>\n              <span className=\"content\">{todoItem.content}</span>\n              <a className=\"del\" onClick={(e)=>{\n                e.stopPropagation();\n                const itemIdx = list.findIndex(item => item.id === todoItem.id);\n                list.splice(itemIdx, 1);\n                updateState({\n                  list\n                });\n                saveStore();\n              }}>×</a>\n            </div>)\n          }\n          {/* 当当前列表没有事项时，显示提示文字 */}\n          {\n            !renderList.length && <div className=\"no-record\">暂无记录</div>\n          }\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}